@using ITVisions.Blazor.Controls
@using ITVisions

<Debug>
 @Template

 @FormFields.Count
</Debug>

@if (!string.IsNullOrWhiteSpace(Template) && FormFields != null && FormFields.Any())
{
 @if (!string.IsNullOrEmpty(ValidationErrorMessage))
 {
  <div class="alert alert-danger" role="alert">
   @((MarkupString)ValidationErrorMessage)
  </div>
 }

 <EditForm Model="this" OnValidSubmit="OnSubmit">

  @* Seiten-Navigation anzeigen, wenn mehrere Seiten vorhanden sind *@
  @if (Pages.Count > 1)
  {
   <div class="page-header mb-4">
    <h3>Seite @(CurrentPageIndex + 1) von @Pages.Count: @Pages[CurrentPageIndex].PageName</h3>

    @* Fortschrittsanzeige *@
    <div class="progress mt-3" style="height: 25px;">
     @{
      var progressPercentage = ITVisions.MathUtil.PerCent(CurrentPageIndex+1, Pages.Count);
     }
     <div class="progress-bar progress-bar-striped progress-bar-animated bg-warning"
          role="progressbar" 
          style="width: @(progressPercentage)%"
          aria-valuenow="@(CurrentPageIndex + 1)" 
          aria-valuemin="0" 
          aria-valuemax="@Pages.Count">
      <strong>@ITVisions.MathUtil.PerCentString(CurrentPageIndex+1, Pages.Count)</strong>
     </div>
    </div>
   </div>
  }

  @* Aktuelle Seite rendern *@
  @if (Pages.Count > 0 && CurrentPageIndex < Pages.Count)
  {
   var currentPage = Pages[CurrentPageIndex];

   @* Felder der aktuellen Seite *@
   @foreach (var field in currentPage.Fields)
   {
    @* Headline innerhalb der Seite *@
    @if (field.Type == FieldType.Headline)
    {
     var isCollapsed = CollapsedSections.Contains(field.Key);
     <h4 class="headline" @onclick="@(() => ToggleSection(field.Key))" style="cursor: pointer; user-select: none;">
      <i class="bi bi-chevron-@(isCollapsed ? "down" : "right") me-2"></i>
      @field.Label
     </h4>
    }
    else
    {
     @* Prüfe ob das Feld angezeigt werden soll (nicht eingeklappt) *@
     var parentHeadline = GetParentHeadline(field, currentPage.Fields);
     var shouldShow = parentHeadline == null || !CollapsedSections.Contains(parentHeadline.Key);

     @if (shouldShow)
     {
      <div class="form-group">
      @if (!string.IsNullOrEmpty(field.Label))
      {
      <label class="fw-bold">
       @field.Label
       @if (field.Required)
       {
        <span style="margin-left:5px" title="Pflichtfeld" class="text-danger">*</span>
       }
       @if (!string.IsNullOrEmpty(field.Note))
       {
         <InfoIcon Icon="ℹ️" Text="@field.Note" />
    
       }
      </label>
     }

     @if (field.Type == FieldType.RadioButtons)
    {
     <div class="d-flex gap-3">
      @foreach (var option in field.Options)
      {
       <div class="form-check">
        <input class="form-check-input" type="radio" name="@field.Key" id="@($"{field.Key}_{option}")" 
               value="@option" @onchange="@(e => { field.ValueString = option; NotifyValuesChanged(); })" 
               checked="@(field.ValueString == option)" />
        <label class="form-check-label" for="@($"{field.Key}_{option}")">@option</label>
       </div>
      }
     </div>
    }
    else if (field.Type == FieldType.CheckBox)
    {
     <div class="form-check">
      <input class="form-check-input" type="checkbox" id="@field.Key" 
             checked="@(!string.IsNullOrEmpty(field.ValueString))" 
             @onchange="@(e => { field.ValueString = ((bool)e.Value) ? field.Options[0] : ""; NotifyValuesChanged(); })" />
      <label class="form-check-label" for="@field.Key">@field.Options[0]</label>
     </div>
    }
    else if (field.Type == FieldType.Select)
    {
     <select class="form-select" @bind="field.ValueString" @bind:after="NotifyValuesChanged" required="@field.Required">
      <option value="">Bitte wählen...</option>
      @foreach (var option in field.Options)
      {
       <option value="@option">@option</option>
      }
     </select>
    }
    else if (field.Type == FieldType.Multiselect)
    {
     <div class="d-flex flex-column gap-2">
      @foreach (var option in field.Options)
      {
       var isSelected = field.ValueString?.Split('|').Select(v => v.Trim()).Contains(option) ?? false;
       <div class="form-check">
        <input class="form-check-input" type="checkbox" id="@($"{field.Key}_{option}")" 
               checked="@isSelected"
               @onchange="@(e => HandleMultiselectChange(field, option, (bool)e.Value))" />
        <label class="form-check-label" for="@($"{field.Key}_{option}")">@option</label>
       </div>
      }
     </div>
    }
    else if (field.Type == FieldType.Rating)
    {
     <div class="d-flex gap-2 align-items-center">
      @foreach (var option in field.Options)
      {
       var isSelected = field.ValueString == option;
         <button type="button" class="btn btn-outline-secondary"
               style="min-width: 40px;"
               @onclick="@(() => { field.ValueString = option; NotifyValuesChanged(); })">
        @if (isSelected)
        {
         <span>★</span>
        }
        else
        {
         <span>☆</span>
        }
        @option
       </button>
      }
      @if (!string.IsNullOrEmpty(field.ValueString))
      {
       <button type="button" class="btn btn-sm btn-link" @onclick="@(() => { field.ValueString = ""; NotifyValuesChanged(); })">Zurücksetzen</button>
      }
     </div>
    }
    else if (field.Type == FieldType.Range)
    {
     <div class="d-flex gap-3 align-items-center">
      <input type="range" class="form-range" style="flex: 1;" 
             @bind="field.ValueString" 
             @bind:after="NotifyValuesChanged" 
             min="@field.Min" 
             max="@field.Max" 
             required="@field.Required" />
      <span class="badge bg-primary" style="min-width: 50px;">@field.ValueString</span>
     </div>
    }
    else if (field.Type == FieldType.Text)
    {
     <input type="text" class="form-control" @bind="field.ValueString" @bind:after="NotifyValuesChanged" required="@field.Required" />
    }
    else if (field.Type == FieldType.TextArea)
    {
     var rows = field.Options?.Count > 0 && int.TryParse(field.Options[0], out int r) ? r : 4;
     <textarea class="form-control" rows="@rows" @bind="field.ValueString" @bind:after="NotifyValuesChanged" required="@field.Required"></textarea>
    }
    else if (field.Type == FieldType.Number)
    {
     <input type="number" class="form-control" 
            @bind="field.ValueString" 
            @bind:after="NotifyValuesChanged" 
            min="@field.Min" 
            max="@field.Max" 
            required="@field.Required" />
    }
    else if (field.Type == FieldType.Date)
    {
     <input type="date" class="form-control" @bind="field.ValueDateTime" @bind:after="NotifyValuesChanged" required="@field.Required" />
    }
    else if (field.Type == FieldType.Time)
    {
       <input type="time" class="form-control" @bind="field.ValueDateTime" @bind:after="NotifyValuesChanged" required="@field.Required" />
    }
    else if (field.Type == FieldType.Email)
    {
     <input type="email" class="form-control" @bind="field.ValueString" @bind:after="NotifyValuesChanged" required="@field.Required" />
    }
    else if (field.Type == FieldType.Password)
    {
     <input type="password" class="form-control" @bind="field.ValueString" @bind:after="NotifyValuesChanged" required="@field.Required" />
    }
    else if (field.Type == FieldType.Url)
    {
     <input type="url" class="form-control" @bind="field.ValueString" @bind:after="NotifyValuesChanged" required="@field.Required" />
    }
    else if (field.Type == FieldType.Phone)
    {
     <input type="tel" class="form-control" 
            @bind="field.ValueString" 
            @bind:after="NotifyValuesChanged" 
            pattern="[0-9\s\-\+\(\)\/]+" 
            title="Nur Zahlen und Sonderzeichen (+, -, /, Leerzeichen, Klammern) erlaubt"
            required="@field.Required" />
    }
      </div>
     }
    }
   }
  }

  @* Navigation und Submit Buttons *@
  <div class="d-flex align-items-center mt-4 pt-3 border-top">
   @if (Pages.Count > 1)
   {
    @if (CurrentPageIndex > 0)
    {
     <button type="button" class="btn btn-secondary me-2" @onclick="PreviousPage" disabled="@(CurrentPageIndex == 0)">
      <i class="bi bi-arrow-left"></i> Vorherige Seite
     </button>
    }
    @if (CurrentPageIndex < Pages.Count - 1)
    {
     <button type="button" class="btn btn-primary me-2" @onclick="NextPage">
      Nächste Seite <i class="bi bi-arrow-right"></i>
     </button>
    }
    else if (ShowSubmitButton)
    {
     <ITVButton type="submit" class="btn btn-primary me-2">
      <i class="bi bi-check-circle"></i> @SubmitButtonText
     </ITVButton>
    }
   }
   else if (ShowSubmitButton)
   {
    <div class="ms-auto">
     <ITVButton type="submit" class="btn btn-primary">
      <i class="bi bi-check-circle"></i> @SubmitButtonText
     </ITVButton>
    </div>
   }
  
  </div>
 </EditForm>
}

@code {
 [Parameter]
 public string Template { get; set; }

 [Parameter]
 public EventCallback<FormFieldList> OnValuesChanged { get; set; }

  [Parameter]
 public EventCallback<FormFieldList> OnSubmited { get; set; }

 [Parameter]
 public bool ShowSubmitButton { get; set; } = true;

 [Parameter]
 public string SubmitButtonText { get; set; } = "Absenden";

 private FormFieldList FormFields { get; set; } = new();
 private string ValidationErrorMessage { get; set; } = "";
 private HashSet<string> CollapsedSections { get; set; } = new();
 private List<FormPage> Pages { get; set; } = new();
 private int CurrentPageIndex { get; set; } = 0;

 private class FormPage
 {
  public string PageName { get; set; }
  public FormField ChapterField { get; set; }
  public List<FormField> Fields { get; set; } = new();
 }

 protected override void OnParametersSet()
 {
  if (!string.IsNullOrEmpty(Template))
  {
   FormFields = TextTemplateFormParser.Parse(Template);
   BuildPages();
  }
 }

 private void BuildPages()
 {
  Pages.Clear();
  CurrentPageIndex = 0;

  FormPage currentPage = null;

  foreach (var field in FormFields)
  {
   if (field.Type == FieldType.Chapter)
   {
    // Neue Seite für jedes Chapter beginnen
    currentPage = new FormPage
    {
     PageName = field.Label,
     ChapterField = field
    };
    Pages.Add(currentPage);
   }
   else
   {
    // Wenn noch keine Seite existiert, erstelle eine Standard-Seite
    if (currentPage == null)
    {
     currentPage = new FormPage
     {
      PageName = "Formular",
      ChapterField = null
     };
     Pages.Add(currentPage);
    }

    // Füge Feld zur aktuellen Seite hinzu (auch Headlines)
    currentPage.Fields.Add(field);
   }
  }

  // Wenn keine Seiten erstellt wurden, erstelle eine Standard-Seite
  if (Pages.Count == 0)
  {
   Pages.Add(new FormPage
   {
    PageName = "Formular",
    ChapterField = null,
    Fields = FormFields.Where(f => f.Type != FieldType.Chapter).ToList()
   });
  }
 }

 private FormField GetParentHeadline(FormField field, List<FormField> fieldsInPage)
 {
  // Finde die letzte Headline vor diesem Feld
  var fieldIndex = fieldsInPage.IndexOf(field);
  if (fieldIndex == -1) return null;

  for (int i = fieldIndex - 1; i >= 0; i--)
  {
   if (fieldsInPage[i].Type == FieldType.Headline)
   {
    return fieldsInPage[i];
   }
  }

  return null;
 }

 private void NextPage()
 {
  if (CurrentPageIndex < Pages.Count - 1)
  {
   // Validierung der aktuellen Seite vor dem Wechsel
   if (!ValidateCurrentPage())
   {
    StateHasChanged();
    return;
   }

   ValidationErrorMessage = ""; // Fehlermeldung zurücksetzen
   CurrentPageIndex++;
   CollapsedSections.Clear(); // Zurücksetzen der eingeklappten Sektionen
   StateHasChanged();
  }
 }

 private void PreviousPage()
 {
  if (CurrentPageIndex > 0)
  {
   ValidationErrorMessage = ""; // Fehlermeldung zurücksetzen beim Zurückgehen
   CurrentPageIndex--;
   CollapsedSections.Clear(); // Zurücksetzen der eingeklappten Sektionen
   StateHasChanged();
  }
 }

 private void ToggleSection(string sectionKey)
 {
  if (CollapsedSections.Contains(sectionKey))
  {
   CollapsedSections.Remove(sectionKey);
  }
  else
  {
   CollapsedSections.Add(sectionKey);
  }
 }

 private async void NotifyValuesChanged()
 {
  await OnValuesChanged.InvokeAsync(FormFields);
 }

 private void HandleMultiselectChange(FormField field, string option, bool isChecked)
 {
  var selectedValues = string.IsNullOrEmpty(field.ValueString)
   ? new List<string>()
   : field.ValueString.Split('|').Select(v => v.Trim()).ToList();

  if (isChecked && !selectedValues.Contains(option))
  {
   selectedValues.Add(option);
  }
  else if (!isChecked && selectedValues.Contains(option))
  {
   selectedValues.Remove(option);
  }

  field.ValueString = string.Join("| ", selectedValues);
  NotifyValuesChanged();
 }

 private bool ValidateCurrentPage()
 {
  ValidationErrorMessage = "";

  if (Pages.Count == 0 || CurrentPageIndex >= Pages.Count)
   return true;

  var currentPage = Pages[CurrentPageIndex];
  var missingFields = new List<string>();
  var invalidFields = new List<string>();

  foreach (var field in currentPage.Fields.Where(f => f.Type != FieldType.Headline && f.Type != FieldType.Chapter))
  {
   var isEmpty = string.IsNullOrWhiteSpace(field.ValueString);

   // Prüfe Pflichtfelder
   if (field.Required && isEmpty)
   {
    missingFields.Add(field.Label);
    continue;
   }

   // Prüfe Format-Validierung für gefüllte Felder
   if (!isEmpty)
   {
    var isValid = ValidateFieldFormat(field);
    if (!isValid)
    {
     invalidFields.Add(field.Label);
    }
   }
  }

  var errors = new List<string>();
  if (missingFields.Any())
  {
   errors.Add($"Bitte füllen Sie folgende Pflichtfelder aus: {string.Join(", ", missingFields)}");
  }
  if (invalidFields.Any())
  {
   errors.Add($"Folgende Felder haben ein ungültiges Format: {string.Join(", ", invalidFields)}");
  }

  if (errors.Any())
  {
   ValidationErrorMessage = string.Join("<br>", errors);
   return false;
  }

  return true;
 }

 private bool ValidateFieldFormat(FormField field)
 {
  if (string.IsNullOrWhiteSpace(field.ValueString))
   return true;

  switch (field.Type)
  {
   case FieldType.Email:
    return System.Text.RegularExpressions.Regex.IsMatch(field.ValueString, 
     @"^[^@\s]+@[^@\s]+\.[^@\s]+$");

   case FieldType.Phone:
    return System.Text.RegularExpressions.Regex.IsMatch(field.ValueString, 
     @"^[0-9\s\-\+\(\)\/]+$");

   case FieldType.Url:
    return Uri.TryCreate(field.ValueString, UriKind.Absolute, out var uriResult) 
     && (uriResult.Scheme == Uri.UriSchemeHttp || uriResult.Scheme == Uri.UriSchemeHttps);

   default:
    return true;
  }
 }

 private async Task OnSubmit()
 {
  // Validierung aller Pflichtfelder beim finalen Submit
  ValidationErrorMessage = "";
  var missingFields = new List<string>();

  foreach (var field in FormFields.Where(f => f.Required && f.Type != FieldType.Headline && f.Type != FieldType.Chapter))
  {
   var isEmpty = string.IsNullOrWhiteSpace(field.ValueString);

   if (isEmpty)
   {
    missingFields.Add(field.Label);
   }
  }

  if (missingFields.Any())
  {
   ValidationErrorMessage = $"Bitte füllen Sie folgende Pflichtfelder aus: {string.Join(", ", missingFields)}";
   StateHasChanged();
   return;
  }

  await OnValuesChanged.InvokeAsync(FormFields);
  await OnSubmited.InvokeAsync(FormFields);
 }

 public FormFieldList GetFormFields()
 {
  return FormFields;
 }

}