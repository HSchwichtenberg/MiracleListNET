@page "/Samples/ProgressBar"
@using System.Threading;
@using ITVisions.Blazor
@inject BlazorUtil Util

<h3>Fortschrittsanzeige</h3>
Iterationen:
<input type="number" @bind="anzahl" />
<button @onclick="StartFortschritt_SoIstEsRichtig" class="btn btn-success">Starte Vorgang</button>
<button @onclick="StartFortschritt_SoGehtEsNicht" class="btn btn-warning">Starte Vorgang (so geht es nicht)</button>
<button @onclick="Abbruch" class="btn btn-danger">Abbruch</button>

<div style="display: block;background-color:#f1f1f1!important">
 <div style="display: block;background-color:lawngreen;width:@Fortschritt%">Fortschritt:&nbsp;@Fortschritt%</div>
</div>

@code {
 private int Fortschritt { get; set; } = 0;
 private CancellationTokenSource cts = new CancellationTokenSource();
 public int anzahl { get; set; }

 protected override void OnInitialized()
 {
  anzahl = Util.IsWebAssembly ? 20000 : 200000; // Da Blazor WebAssembly langsamer ist, hier nicht so viele        Iterationen; -)
 }

 // Das funktioniert NICHT, weil Blazor das Virtual DOM erst mit dem echten DOM synchronisiert, sobald der Main Thread nicht mehr blockiert ist!!!
 void StartFortschritt_SoGehtEsNicht()
 {
  this.Fortschritt = 0;
  for (int i = 0; i < 20; i++)
  {
   // Berechnungen().Start() ist nur ein Beispiel für den Aufruf irgendeiner Methode, die etwas tut, was etwas dauert
   new Berechnungen().Start(1000000, this.Fortschritt, this.Fortschritt + 5);
   this.Fortschritt += 5;
   Util.Log("Fortschritt: " + Fortschritt + "%");
  }
 }

 // Die richtige Lösung ist, die Berechnung in einen getrennten Thread auszulagern und damit den Hauptthread freizugeben.d.
 async Task StartFortschritt_SoIstEsRichtig()
 {
  Util.Log("StartFortschritt");
  this.Fortschritt = 0;
  cts = new CancellationTokenSource();
  await Task.Run(async () =>
  {
   Util.Log("Start Task...");
   for (int i = 0; i < 20; i++)
   {
    if (cts.IsCancellationRequested) { await this.InvokeAsync(this.StateHasChanged); Util.Log("Task abgebrochen!"); break; }

    // Berechnungen().Start() ist nur ein Beispiel für den Aufruf irgendeiner Methode, die etwas tut, was etwas dauert
    new Berechnungen().Start(anzahl, this.Fortschritt, this.Fortschritt + 5);

    this.Fortschritt += 5;
    Util.Log("Fortschritt: " + Fortschritt + "%");

    if (Util.IsWebAssembly)
    {
     this.StateHasChanged();
     await Task.Delay(1); // Delay ist für Blazor WebAssembly notwendig
    }
    else if (Util.IsBlazorServer || Util.IsHybrid)
    {
     await this.InvokeAsync(this.StateHasChanged);
    }
    else
    {
     Util.Error("Unerwartete Blazor-Variante!");
    }
   }
  }, cts.Token);

  cts = null;
 }

 async void Abbruch()
 {
  if (cts != null) cts.Cancel();
  await Util.Alert("Abgebrochen!");
 }

 protected async override Task OnAfterRenderAsync(bool firstRender)
 {
  Util.Log("OnAfterRenderAsync(firstRender=" + firstRender + ")");
 }

}